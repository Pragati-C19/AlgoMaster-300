import java.util.*;

public class MinMalwareSpread {
    
    // Globally Declare Variables
    Map<Integer, List<Integer>> graphMap;
    Set<Integer> initialInfectedNodeSet; 

    // Driver Function
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        // Declare Variables 
        int n = graph.length;
        int infectedNodeCount = 0;
        // boolean[] visitedNode = new boolean[n];
        graphMap = new HashMap<>();
        initialInfectedNodeSet = new HashSet<>();


        // Add initial in the set to check later that we are not infecting the same node
        for (int infectedNode : initial) {

            initialInfectedNodeSet.add(infectedNode);
        }
        System.out.println("InfectedNode Set : " + initialInfectedNodeSet);


        // Add dependencies in map
        for (int node = 0; node < n; node++) {
            for (int neighbor = 0; neighbor < n; neighbor++) {
                
                if (node == neighbor) {

                    System.out.println("    node == neighbor so skipping...");
                    continue;
                }

                if (graph[node][neighbor] == 1) {
                    
                    if (!graphMap.containsKey(node)) {
                        graphMap.put(node, new ArrayList<>());
                    }

                    graphMap.get(node).add(neighbor);
                }
            }
        } 
        System.out.println("Graph Map : " + graphMap);

        
        // infect connections of nodes
        for (int node : initial) {
            
            // fresh visited array for each DFS run to avoid side effects
            boolean[] visitedNode = new boolean[n];
            
            infectedNodeCount += dfs(node, visitedNode);
            System.out.println("    -> Initial " + node + " infected " + infectedNodeCount + " new nodes");
        }


        return infectedNodeCount;
    }

    // Recursion Function : to check how many nodes are affected
    private int dfs(int currNode, boolean[] visitedNode) {

        // Base Case :
        if (visitedNode[currNode]) {
            
            System.out.println("        - Node(" + currNode + ") is already visited...");
            return 0;
        } 

        // mark as visited
        visitedNode[currNode] = true;

        // decalre a count to get currInfected nodes
        int currInfectedNodeCount = 1;

        // check it's neighbors
        if (graphMap.containsKey(currNode)) {
            
            List<Integer> neighborOfCurrNode = graphMap.get(currNode);

            for (int neighbor : neighborOfCurrNode) {
                
                if (!initialInfectedNodeSet.contains(currNode)) {
                    
                    currInfectedNodeCount += dfs(neighbor, visitedNode);
                }
            }
        }

        System.out.println("        - Infected Node Count for node " + currNode + " : " + currInfectedNodeCount);
        return currInfectedNodeCount;
    }

    public static void main(String[] args) {
    
        MinMalwareSpread solution = new MinMalwareSpread();

        int[][] graph1 = {
            {1, 1, 0},
            {1, 1, 0},
            {0, 0, 1}
        };
        int[] initial1 = {0, 1};
        System.out.println("Result 1 -> " + solution.minMalwareSpread(graph1, initial1) + "\n");

        int[][] graph2 = {
            {1, 0, 0},
            {0, 1, 0},
            {0, 0, 1}
        };
        int[] initial2 = {0, 2};
        System.out.println("Result 2 -> " + solution.minMalwareSpread(graph2, initial2) + "\n");

        int[][] graph3 = {
            {1, 1, 1},
            {1, 1, 1},
            {1, 1, 1}
        };
        int[] initial3 = {1, 2};
        System.out.println("Result 3 -> " + solution.minMalwareSpread(graph3, initial3) + "\n");

    }
    
}

/*
 * Intuitions :
 
    1. we have given a netwrok of n nodes represented by n x n adj matrix
    2. i'th node is directly connected to j'th node if graph[i][j] = 1
        means we can say row (i) is node and col (j) is neighbor
    3. some nodes (initial) infected by malware
    4. if any of the node is infected by malware then it's connected nodes are also infected by malware
    
 
 
 * Pattern :
 
    ^ Trace Example :

        1. graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]

            - connections between node
                0 -> 0, 1
                1 -> 0, 1
                2 -> 2
            - so as per the que it say initials are infected nodes and it can affect it's connection
                0 is infected check it's connection which is 1 it is also infected
                1 is infected check it's connection which is 0 it is also infected
                2 is not connected to any infected nodes so it is safe
            - as we haven't affect any new node will return 0

            - what happening here?
                we are checking initial nodes 
                checking it's connection one by one 
                if the connection in initial we are skipping it 
                if connection is not in initial we are changing it and increasing the newInfectedNode count

 
 * Pseudo Code :
 
    1. First approach with brute force 

        function minMalwareSpread (graph, initial) {
        
            -> Declare variables
                n = graph.length
                Map<Integer, List<Integer>> graphMap    -> to store dependencies
                infectedNodeCount = 0                   -> it will store how many new nodes get infected bcoz of initial
                Set<Integer> initialInfectedNodeSet     -> store infected nodes mention in initial
                boolean[] visitedNode                   -> it will tell if the node is already visited or not


            -> add initiallly infected nodes in set
                for(infectedNode : initial)

                    infectedNodeSet.add(infectedNode)


            -> add key and value in map
                for(node = 0 to n)
                    for(neighbor = 0 to n)

                        -> if i and j are equal skip to add it in map it's a self dependencies
                            if(i = j) continue

                        -> if [row][col] is 1 then that's connected we need to add it in map
                            if(graph[node][neighbor] == 1)

                                if(!map.contains(node))
                                    map.put(node, new array)

                                map.get(node).add(neighbor)
                        
            -> now let's check initials one by one
                for(int infectedNode : initial)

                    infectedNodeCount += dfs(currNode, visitedNode, initialInfectedNodeSet, graphMap)
        
        }


        dfs (currNode, visitedNode, initialInfectedNodeSet, graphMap) {
        
            -> Base Case : node is already visited or already infected will skipp it
            if(visitedNode[currNode] || infectedNodeSet.contains(currNode))
                return 0

            -> otherwise mark as visited
                visitedNode[currNode] = true

            -> increase infected count 
                int currInfectedNodeCount++

            -> check neighbors 
                if(map.contains(currNode))
                    for(neighbor : map.get(currNode))
                        
                        currInfectedNodeCount += dfs(neighbor, visitedNode, initialInfectedNodeSet, graphMap)

            -> return currInfectedNodeCount
        }

 */