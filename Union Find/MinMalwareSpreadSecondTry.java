import java.util.*;

public class MinMalwareSpreadSecondTry {
    
    // Disjoint Set Union Class
    private static class DSU {

        // Declare variables Globally for function in the class
        
        int[] parent;   // tells who is the leader of each element
        int[] rank;     // tells how tall the tree is
        int[] size;     // tells how many elements are there in the group

        // Constructor: initialize DSU with n elements (make each element its own parent)
        public DSU (int n) {

            // we use 0-based indexing
            parent = new int[n]; 
            rank = new int[n];
            size = new int[n];

            for (int i = 0; i < n; i++) {
                
                parent[i] = i;  // everyone is their own leader at the start
                rank[i] = 0;    // height is 0 at the start
                size[i] = 1;    // there is at least one element at the start ((only itself))
            }

        }

        // Find the ultimate leader of the group for an element
        public int findParent (int currElement) {

            if (currElement == parent[currElement]) {
                return currElement; // if it's its own parent, it's the leader
            }

            // find the leader and update it (path compression)
            parent[currElement] = findParent(parent[currElement]);
            
            return parent[currElement];

        }

        // Union by Rank: attach smaller height tree under taller tree
        public void unionByRank (int firstElement, int secondElement) {

            // Get parent of both elementes
            int parent1 = findParent(firstElement);
            int parent2 = findParent(secondElement);

            if (parent1 == parent2) {
                
                // Already in the same set
                return;
            }

            // Attach lower rank tree under higher rank tree
            if (rank[parent1] < rank[parent2]) {
                
                parent[parent2] = parent1;
            }
            else if (rank[parent1] > rank[parent2]) {
                
                parent[parent1] = parent2;
            }
            else {

                // both same height, anyone can be parent and increase height by 1
                parent[parent2] = parent1;
                rank[parent1]++;
            }

            return;
        }

        // Union by Size: attach set with less memebers under set with more memebers
        public void unionBySize (int firstElement, int secondElement) {

            // Get parent of both elementes
            int parent1 = findParent(firstElement);
            int parent2 = findParent(secondElement);

            if (parent1 == parent2) {
                
                // Already in the same set
                return;
            }

            // Attach smaller size tree under bigger size tree
            if (size[parent1] < size[parent2]) {
                
                parent[parent2] = parent1;
                size[parent1] += size[parent2]; 
            }
            else if (rank[parent1] > rank[parent2]) {
                
                parent[parent1] = parent2;
                size[parent2] += size[parent1]; 
            }
            else {

                // both same size, anyone can be parent and increase size 
                parent[parent2] = parent1;
                size[parent1] += size[parent2]; 
            }

            return;
        }

    }

    
    // Driver Function
    public int minMalwareSpread(int[][] graph, int[] initial) {
        
        int n = graph.length;
        
        // Declare DSU 
        DSU dsu = new DSU(n);

        // Build group with the help of union
        for (int node = 0; node < n; node++) {
            for (int neighbor = 0; neighbor < n; neighbor++) {
                
                if (node == neighbor) {

                    System.out.println("    node is equal to neighbor so skipping...");
                    continue;
                }

                if (graph[node][neighbor] == 1) {
                    
                    dsu.unionBySize(node, neighbor);
                }
            }
        }
      
        // Count How many infected nodes are there in groups 
        int[] infectedNodeCountInGroups = new int[n];
        
        for (int infectedNode : initial) {
            
            int nodeBelongsToGroup = dsu.findParent(infectedNode);

            // increase the infected node count for that group
            infectedNodeCountInGroups[nodeBelongsToGroup]++;
        }
        System.out.println("Infected Node Count in all groups : " + Arrays.toString(infectedNodeCountInGroups));

        // Sort initial array just incase we got a tie and we need a small node
        Arrays.sort(initial);
        System.out.println("Sorted Initial Array : " + Arrays.toString(initial));
        

        // Find a node to remove so that minimum nodes will get affected
        // wrote -1 bcoz I needed a initial count there we can use MAX_Value ot MIN_Value too, just use anything except nums > 0
        int maxSavedNodesCount = -1;
        int removeNode = -1;   

        for (int currInfectedNode : initial) {
            
            // get which group that node belongs too
            int nodeBelongsToGroup = dsu.findParent(currInfectedNode);

            // check if there is any group with only 1 infected node
            if (infectedNodeCountInGroups[currInfectedNode] == 1) {
                
                int currSavedNodesCount = dsu.size[nodeBelongsToGroup];
                System.out.println("    -> Initial " + currInfectedNode + " infected " + currSavedNodesCount + " new nodes");

                if (currSavedNodesCount > maxSavedNodesCount) {

                    maxSavedNodesCount = currSavedNodesCount;
                    removeNode = currInfectedNode;

                    System.out.println("    -> currInfectedNode can save maximum nodes than prev infectedNode so now removeNode and savedNodeCount is " + removeNode + " : " + maxSavedNodesCount);
                }
            }
        }

        return n;
    }


    public static void main(String[] args) {
    
        MinMalwareSpreadSecondTry solution = new MinMalwareSpreadSecondTry();

        int[][] graph1 = {
            {1, 1, 0},
            {1, 1, 0},
            {0, 0, 1}
        };
        int[] initial1 = {0, 1};
        System.out.println("Result 1 -> " + solution.minMalwareSpread(graph1, initial1) + "\n");

        int[][] graph2 = {
            {1, 0, 0},
            {0, 1, 0},
            {0, 0, 1}
        };
        int[] initial2 = {0, 2};
        System.out.println("Result 2 -> " + solution.minMalwareSpread(graph2, initial2) + "\n");

        int[][] graph3 = {
            {1, 1, 1},
            {1, 1, 1},
            {1, 1, 1}
        };
        int[] initial3 = {1, 2};
        System.out.println("Result 3 -> " + solution.minMalwareSpread(graph3, initial3) + "\n");

        int[][] graph4 = {
            {1, 0, 1, 0},
            {0, 1, 0, 0},
            {1, 0, 1, 0},
            {0, 0, 0, 1}
        };
        int[] initial4 = {1};
        System.out.println("Result 4 -> " + solution.minMalwareSpread(graph4, initial4) + "\n");

        int[] initial5 = {0, 1, 2};
        System.out.println("Result 5 -> " + solution.minMalwareSpread(graph1, initial5) + "\n");
    }
    
}

/*
 * Intuitions :
 
   1. Again Trying to solve 924. Minimize Malware Spread que
   2. Will use DSU logic here now

   3. Recap the que again : 
        - We have n nodes (computers), connected with each other.
        - The connection info is in a 2D matrix graph (adjacency matrix).
        - Some nodes are infected initially (initial array).
        - Malware spreads to all connected nodes (if any node in a connected group is infected, all in that group become infected).
        - We want to remove exactly one node from initial to minimize the final infected nodes.
        - If multiple choices, return the node with the smallest index.
 
    4. How DSU will help us here ?
        - DSU / Union-Find helps us group nodes into connected components easily.
 

 * Pattern :
 
    1. What are we going to do?
        - Ek connected group hota (connected component) where all nodes are connected directly or indirectly.
        - Malware spreads in entire connected group if even one node is infected.
        - So, first step: find connected components using DSU.
        - Each component has some nodes and maybe some infected nodes.
        - If a component has exactly 1 infected node, then removing that infected node from initial will save the entire component from infection.
        - Among all such nodes, choose the one which saves the largest number of nodes.
        - If tie, choose node with smallest index.

    2. Create a DSU with (0 - based indexed) bcoz our nodes are
    3. Build group with the help of union
        - it's so similar like creating a dependency graphMap I do in DFS
        - it will create a group just like we do create list in map
    4. Will count how many infected nodes are there Initially in each group
        - just think abt initial nodes not it's dependency nodes te apoap work hoil as we know the group
        - find parent of that initial infected node
        - increase the infected node count of that parent 
    5. Sort the initial incase we got a tie we need to return smallest node
    6. Find node to remove so that minimum nodes will get infected
        - maxSavedNodesCount : it tells aata paryant kontya node la remove kele tar saglyat jast nodes save hotay.
        - removeNode : this tells use which node we should remove at the end so that malware spread jast nodes vr nahi honar
        - now find which group that currNode belongs to 
        - ata check kr tya group madhe initial infected nodes ekach ahe ka te?
            why 1 ?
                Suppose eka group madhe 2 infected nodes ahet (e.g. node 0 and node 1).
                apan 0 remove kela still 1 mule to group again infected hoilch 
                so use nahiye tya group la save karaycha
        - to 1 node infected vala group bhetla ki apan sie check karu tya group chi kiti ahe te
        - jevha ek infected node remove karto, tevha konta group save hotoy and tya group madhe kiti nodes ahes?
                to check that currSavedNodes = dsu.size[root]
        - so jevha currSavedNodesCount > maxSavedNodesCount asel means apalyala better option bhettoy so will change 
            - maxSaved = currSaved
            - removedNode = currNode

 
    
 */